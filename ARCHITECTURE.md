# 架构设计文档

## 1. 设计理念

本项目旨在演示如何在不同的Rust Web框架（Axum、Actix Web、Rocket）之间共享业务逻辑，同时保持各框架的特性优势。通过使用Cargo工作区和特性驱动开发，实现了代码的最大复用和最小冗余。

### 1.1 核心目标

- 在不同Web框架中复用业务逻辑和数据访问代码
- 统一API响应格式和参数验证机制
- 支持多种ORM/数据库访问方式（SQLx、Diesel、SeaORM）
- 提供可配置的服务启动方式

### 1.2 设计原则

1. **关注点分离**：将业务逻辑与Web框架解耦，确保业务代码的可移植性
2. **特性驱动**：通过Cargo特性动态切换数据库实现，避免运行时开销
3. **统一接口**：为不同的ORM实现提供统一的接口抽象
4. **类型安全**：充分利用Rust的类型系统确保代码正确性

## 2. 架构模式

### 2.1 整体架构

项目采用多框架并行 + 公共库共享的工作空间（Cargo Workspace）架构：

```
HTTP请求 → 路由 → Controller → Service → Repository → DB
                               ↑         ↑
                       common_validation   实现分支（sqlx/diesel/seaorm）
                               ↓
                      common_wrapper ← 返回结果封装
```

### 2.2 分层架构

1. **控制器层（Controller）**：
   - 处理HTTP请求和响应
   - 参数验证和转换
   - 调用服务层处理业务逻辑

2. **服务层（Service）**：
   - 实现核心业务逻辑
   - 事务管理
   - 调用数据访问层

3. **数据访问层（Repository）**：
   - 提供统一的数据访问接口
   - 支持多种ORM实现（SQLx、Diesel、SeaORM）
   - 数据模型转换

### 2.3 工作区模式

使用Cargo工作区统一管理依赖版本，确保一致性：
- 统一依赖管理，避免版本冲突
- 简化依赖管理，只需在一个地方维护依赖版本
- 减少编译时间，相同依赖只编译一次

## 3. 关键技术决策

### 3.1 Cargo特性驱动开发

采用特性（features）机制动态切换数据库实现：
- `sqlx_impl`：使用SQLx作为数据库实现
- `diesel_impl`：使用Diesel作为数据库实现
- `seaorm_impl`：使用SeaORM作为数据库实现

优势：
- 编译时选择实现，避免运行时开销
- 减少二进制文件大小
- 更好的性能和类型安全

### 3.2 公共库设计

通过两个核心公共库实现功能共享：

1. **common_validation**：
   - 提供统一的参数验证机制
   - 支持非空、长度、格式、范围等验证规则
   - 可扩展的验证规则系统

2. **common_wrapper**：
   - 提供统一的API响应封装
   - 支持单数据、列表、分页等响应类型
   - 标准化的错误处理机制

### 3.3 ORM抽象层

为三种不同的ORM实现提供了统一的抽象接口：
- SQLx（异步SQL执行）
- Diesel（编译时安全ORM）
- SeaORM（异步ORM）

通过统一的[DeptRepository](actix_web_demo/src/repositories/dept/dept_repository.rs) trait，上层业务代码无需关心具体使用哪种ORM实现。

## 4. 模块交互关系

### 4.1 数据流向

```
HTTP请求 
    ↓
路由匹配
    ↓
控制器层 (controllers)
    ↓
服务层 (services)
    ↓
数据访问层 (repositories)
    ↓
数据库 (DB)
    ↓
数据访问层 (repositories)
    ↑
服务层 (services)
    ↑
控制器层 (controllers)
    ↑
HTTP响应 (通过common_wrapper封装)
```

### 4.2 依赖注入

项目使用依赖注入模式管理组件间依赖：
- 控制器依赖服务实例
- 服务依赖数据访问实例
- 通过构造函数传递依赖关系

## 5. 设计模式应用

### 5.1 依赖注入
通过构造函数传递数据库连接和服务实例，降低组件间耦合度。

### 5.2 模板方法
在服务层定义通用接口，在具体实现中差异化处理。

### 5.3 响应对象模式
使用`common_wrapper`封装统一返回结构，确保API响应一致性。

### 5.4 构建者模式
用于复杂响应对象的构建（如分页结果）。